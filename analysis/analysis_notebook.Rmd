---
title: "North Santiam Pedigree Project Analysis Notebook"
output:
  html_document:
    df_print: paged
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: false
---

```{r, message = FALSE, warning=FALSE}
require(RLDNe)
require(DHARMa)
require(MASS)
require(lme4)
require(kableExtra)
require(gt)
require(gtsummary)
require(tidyverse)
require(magrittr)
```


# Summary

This notebook contains a log of all analyses for the 2022 North Santiam Chinook salmon genetic pedigree study. Inference of the pedigree used here is conducted in a separate notebook titled "parentage_assignment_log" in this same repository.

__Goals__  
(1) Summarise assignments    
(2) Estimate total lifetime fitness (TLF) for parent cohorts  
(3) Estimate cohort replacement rates for parent cohorts  
(4) Assess variables that influence fitness with general linear models  
(5) Estimate effective number of breeders using NeEstimator  

This is an R notebook. The .html version of this file is a fully rendered and interactive log. To view it, save the html and open in a browse. The .rmd version can be opened within R studio. To reproduce results or edit the analysis: clone the full repository onto tyour local machine and open the r project in rstudio. This will provide all needed data and objects. 

# Data

## Import
Here we import metadata and the final pedigree.

```{r, message=FALSE, warning=FALSE}
load("../parentage/parentage_results/meta_data.R")
load("../parentage/parentage_results/pedigree.R")

# let's get the metadata on the pedigree
pedigree_meta <- meta_data %>%
  select(sample_id, year, type, date) %>%
  rename_with(.fn = ~ paste0("offspring_", .x)) %>%
  right_join(pedigree, by = c("offspring_sample_id" = "offspring_sample_id"))

#father
pedigree_meta <- meta_data %>%
  select(sample_id, year, type, date, above_below) %>%
  rename_with(.fn = ~ paste0("father_", .x)) %>%
  right_join(pedigree_meta, by = c("father_sample_id" = "father")) %>%
  rename(father = father_sample_id)

#mother
pedigree_meta <- meta_data %>%
  select(sample_id, year, type, date, above_below) %>%
  rename_with(.fn = ~ paste0("mother_", .x)) %>%
  right_join(pedigree_meta, by = c("mother_sample_id" = "mother")) %>%
  rename(mother = mother_sample_id)
```

## Dataset Summary

```{r}

tbl_summary(select(meta_data, type, year), by = type, percent = "row") %>%
  modify_header(label ~ "") %>%
  modify_spanning_header(c("stat_1", "stat_2", "stat_3", "stat_4", "stat_5") ~ "**type**") %>%
  as_kable_extra() %>%
  kable_classic(full_width = F, html_font = "Arial")# %>%
```
The dataset described above includes all __sampled__ parents from 2011 - 2017 and all __sampled__ offspring from 2014 - 2020, after filtering for missingness and duplicates.

Note: Some of the results we work with in this report are properties of parents, and others are properties of offspring. Throughout the report we include results for parent years 2011-2015, and offspring years for 2016-2020. The pedigree is complete (full age structure present in dataset) for parent years 2011-2015 and for offspring years 2016-2020.  
For example: Fitness is a property of parents and we report fitness for parent years 2011-2015, so it requires information from additional offspring years that are not part of the range of years for which we report offspring level data (2014 and 2015).  
As another example, while 2014 offspring are included in the pedigree, the complete set of their potential parents are not (2009, 2010). This is because we do not include results for parents years 2009 or 2010, but we do include 2011. Similarly 2017 parents are included in the study because they contribute as parents to 2020 offspring year, but we do not sample their potential age 4 and age 5 offspring, so we do not report full 2017 parent level results.

### Table 2
Let's summarise outplant release locations by location and date to present in table 2.

```{r}
kable(meta_data %>%
  filter(above_below == "above") %>%
  count(year, date, location), align = "c", caption = "Table 2 from draft report totals") %>%
  kable_classic(full_width = F, html_font = "Arial")

kable(meta_data %>%
  filter(above_below == "above", geno_sex == "F") %>%
  count(year, date, location), align = "c", caption = "Table 2 from draft report females") %>%
  kable_classic(full_width = F, html_font = "Arial")

kable(meta_data %>%
  filter(above_below == "above", geno_sex == "M") %>%
  count(year, date, location), align = "c", caption = "Table 2 from draft report males") %>%
  kable_classic(full_width = F, html_font = "Arial")

```


# Assignment Rates

This section calculates number of assignments between different parent and offspring classes. 

## Table 3

Here we format the assignment rates into the format of table 3 from the draft report

Each table in the notebook below can be used to recreate table 3. Each table represents a single pair of offspring and parent years. The type of offspring is listed in the first column and the results are split between parent types along the remaining columns (e.g. same format as table 4)

When the "type" of parent varies between two parents, the female parent type is listed first. This is slightly different from table 4. For example, if an offspring is assigned to a reintroduced mother and carcass father, the column would be called "reintro/carcass."

```{r}
# the format of the table is difficult to produce in r
# let's not change the format of the table, instead we'll write some helper functions for filling it out 

#let's add a column for the type of assignment, and one for combined types
pedigree_meta %<>%
  mutate(assn_type = case_when((mother == "none" & father == "none") ~ "none",
                               (mother == "none" & father != "none") ~ "male_only",
                               (mother != "none" & father == "none") ~ "female_only",
                               (mother != "none" & father != "none") ~ "pair",)) %>%
  mutate(parent_type = case_when((father_type == mother_type) ~ father_type,
                                 (is.na(father_type) & !(is.na(mother_type))) ~ mother_type,
                                  (is.na(mother_type) & !(is.na(father_type))) ~ father_type,
                                   (father_type != mother_type) ~ paste(mother_type, father_type, sep = "/")))

# function
t4_helper <- function(p_year, off_year){pedigree_meta %>%
  filter(offspring_year == off_year) %>%
  mutate(parent_year = (coalesce(father_year, mother_year))) %>%
  filter(parent_year == p_year) %>%
  mutate(parent_type = as.factor(parent_type)) %>%
  select(offspring_type, parent_type, assn_type) %>%
  tbl_strata(
    strata = parent_type,
    .tbl_fun = ~ .x %>%
      tbl_summary( by = assn_type, percent = NULL)
  ) %>%
  modify_caption(paste(paste("parent year: ", p_year), paste("offspring year: ", off_year), sep = "  ,")) %>%
  as_kable_extra() %>%
  kable_classic(full_width = F, html_font = "Arial")
}
```

### Offspring Year 2016
```{r}
#t4 helper function example
t4_helper("2011", "2016")
t4_helper("2012", "2016")
t4_helper("2013", "2016")
```

### Offspring Year 2017
```{r }
t4_helper("2012", "2017")
t4_helper("2013", "2017")
t4_helper("2014", "2017")
```

### Offspring Year 2018
```{r}
t4_helper("2013", "2018")
t4_helper("2014", "2018")
t4_helper("2015", "2018")
```

### Offspring Year 2019
```{r}
t4_helper("2014", "2019")
t4_helper("2015", "2019")
t4_helper("2016", "2019")
```

### Offspring Year 2020
```{r}
t4_helper("2015", "2020")
t4_helper("2016", "2020")
t4_helper("2017", "2020")
```

## Age at Maturity

We can also calculate age at maturity for offspring year using these data. These results appear in the draft report in the text, but we will summarise here in a table.

```{r, message=FALSE, warning=FALSE}

# report text is formatted as number and percent per age for each offspring year

kable(pedigree_meta %>%
        filter(!(offspring_year %in% c("2014", "2015"))) %>%
  mutate(parent_year = (coalesce(father_year, mother_year))) %>%
  filter(!(is.na(parent_year))) %>%
  mutate(age = as.numeric(offspring_year) - as.numeric(parent_year)) %>%
  group_by(offspring_year, age) %>%
  summarise(n = n()) %>%
  mutate(percent = 100*(n/sum(n))), digits = 0) %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  kable_styling(fixed_thead = T) %>%
  collapse_rows(columns = 1)
  
  
```


# Total Lifetime Fitness

In this section, we calculate the number of offspring assigned to parents from the pedigree and calculate summary statistics.

```{r}
#first let's get a dataframe that can be easily used to calculate parent level information
# all candidate parents, the number of time they appear in the pedigree and their metadata

parents <- meta_data %>%
  filter(year %in% 2011:2017) #checked this against the input parent lists, same size

father_counts <- pedigree %>%
  group_by(father) %>%
  count() %>%
  rename(parent = father)

mother_counts <- pedigree %>%
  group_by(mother) %>%
  count() %>%
  rename(parent = mother)

parent_counts <- bind_rows(mother_counts, father_counts) 
rm(mother_counts)
rm(father_counts)

parents %<>%
  left_join(parent_counts, by = c("sample_id" = "parent")) %>%
  rename(tlf = n) %>%
  mutate(tlf = replace_na(tlf, 0))
```

## Table 4
Here we format the TLF results to match table 4 of the draft report.

```{r, message=FALSE, warning=FALSE}
kable(parents %>%
  group_by(year, type, geno_sex) %>%
  summarise(N = n(), mean_tlf = mean(tlf), sd_tlf = sd(tlf), range = paste(min(tlf), " -  ", max(tlf))), align = "c") %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  kable_styling(fixed_thead = T) %>%
  collapse_rows(columns = 1, valign = "top")


```

## Results Text

The results in text combine estimates of TLF across sexes. Let's generate the table above again, without splitting moms and dads.

```{r}
kable(parents %>%
  group_by(year, type) %>%
  summarise(N = n(), mean_tlf = mean(tlf), sd_tlf = sd(tlf), range = paste(min(tlf), " -  ", max(tlf))), align = "c") %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  kable_styling(fixed_thead = T) %>%
  collapse_rows(columns = 1, valign = "top")

```


# Cohort Replacement Rates

Here we estimate the cohort replacement rate across different groups of parents. 

Results are prepared for each of the following groups:   

* Outplants (Above Detroit)   
* Reintroductions (Below Big Cliff)  
* Reintroductions (Above Detroit)  


Within each of the above, calculate for each parent year and each sex. 

```{r, message = FALSE, warning = FALSE}
# data wrangling here is very similar to TLF, maybe we can save some work and use it again

# add offspring sex to pedigree_meta
full_meta <- readxl::read_xlsx("../parentage/parentage_data/full_dataset.xlsx", sheet = 1, col_types = "text")

pedigree_meta %<>%
  left_join(select(full_meta, geno_sex, sample_id), by = c("offspring_sample_id" = "sample_id")) %>%
  mutate(offspring_sex = geno_sex)

father_male_offspring_counts <- pedigree_meta %>%
  filter(offspring_sex == "M") %>%
  group_by(father) %>%
  count() %>%
  rename(parent = father)

mother_female_offspring_counts <- pedigree_meta %>%
  filter(offspring_sex == "F") %>%
  group_by(mother) %>%
  count() %>%
  rename(parent = mother)

parent_counts_same_sex <- bind_rows(mother_female_offspring_counts, father_male_offspring_counts) 
rm(father_male_offspring_counts)
rm(mother_female_offspring_counts)

parents %<>%
  left_join(parent_counts_same_sex, by = c("sample_id" = "parent")) %>%
  rename(same_sex_offspring = n) %>%
  mutate(same_sex_offspring = replace_na(same_sex_offspring, 0))

kable(parents %>%
  group_by(year, type, geno_sex) %>%
  summarise(crr = sum(same_sex_offspring)/n()), align = "c", digits = 2) %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
  kable_styling(fixed_thead = T) 
# Let's check one of these to make sure the code is working correctly. In 2016, there were 452 male outplants. These 452 potential fathers appear in the final pedigree 1092 times. Of these 1092 offspring, 723 is male. Therefore the correct CRR for 2016 male outplants is 1.5995575. This matches the table.
```

The results test also presents CRR not split by sex, but doesn't call it CRR or do the calculation (just presents the number of outplant parents and the number of offspring assigned to them). Let's calculate these below, so it is easier to write this results section. 

```{r}
a <- pedigree_meta %>%
  mutate(parent_year = coalesce(mother_year, father_year)) %>%
  filter(father_type == "outplant" | mother_type == "outplant") %>% 
  group_by(parent_year) %>%
  summarise(offspring_n = n())

b <- full_meta %>%
  filter(type == "outplant") %>%
  count(year) %>%
  rename(parent_year = year, n_outplants = n)

kable(left_join(a,b), align = "c", caption = "total number of offspring that assign to outplants per parent year") %>% kable_classic(full_width = F, html_font = "Cambria") %>%
  kable_styling(fixed_thead = T) 

rm(a)
rm(b)


```

The results text also splits the results above according to carcass and non-carcass.

```{r}
a <- pedigree_meta %>%
  mutate(parent_year = coalesce(mother_year, father_year)) %>%
  filter(father_type == "outplant" | mother_type == "outplant") %>% 
  group_by(parent_year, offspring_type) %>%
  summarise(offspring_n = n())

b <- full_meta %>%
  filter(type == "outplant") %>%
  count(year) %>%
  rename(parent_year = year, n_outplants = n)

kable(left_join(a,b), align = "c", caption = "total number of offspring that assign to outplants per parent year") %>% kable_classic(full_width = F, html_font = "Cambria") %>%
  kable_styling(fixed_thead = T) 

rm(a)
rm(b)


```

# Predictors of Fitness

Here we fit some GLMs on fitness of outplanted salmon. We split the analysis below into two full model specifications: the specification from the draft report and a different model that might have more power to detect significant effects of variables on fitness. 

## Fixed Predictors (GLM)

First we fit the model the same way as the draft report. For each outplant year, Total lifetime fitness ~ sex + release location + release date + sex*release date. All are fixed effects and all but date are factors (categorical). The GLM family is Poisson (log link function, Poisson distribution) and the GLM is evaluated using likelihood ratio test (chi-squared distribution) and individual levels of effects are evaluated with a Wald Tests (automatically done by R so included below) and likelihood-ratio tests (to match what was done previously). 

I also went a little further than what was done before:  
I did model validation by (a) comparing the scaled residuals against rank transformed predicted values and (b) examining a QQ plot for goodness of fit (Kolmogorov–Smirnov test), overdispersion, and outliers. This was added tot report draft.

I also went a little further here, but did not include the follwoing in the report draft. For years with significant full models and significant effects, we conducted stepwise model selection by AIC to find a sparse final model, assessed significance of predictor variables in the final model using a likelihood-ratio test, and assessed significance of individual levels of predictors using a Wald test.  

__Some other notes:__
Note 1:  
The previous workers on this project (Evans, Black, Bohn) all used jmp to fit this model. Specifically, in the previous North Santiam (and South Santiam) reports jmp was used to fit a glm with a poisson distribution. However, the data is a poor fit to the distribution: in each year the response variable demonstrates significant overdispersion. Sard solved this problem by fitting their models using a negative binomial in McKenzie, but previous workers on Santiam adjusted the tests using an "overdispersion parameter estimated by Pearson Chisq/DF." This approach is implemented in the R glm() function by using the "quasipoisson" rather than poisson family for the glm fit, but the authors of the most populat r packages for fitting GLMs believe it is inappropriate to output AIC or likelihood using this "quasipoisson" distribution, while the jmp authors don't seem to have an issue with reporting AIC/likelihoods when the response variable demonstrates overdispersion and report it. Table 5 reports to log-likelihood ratio of individual effects so to get the table with the exact same results, so we need to make a decision here.


I'd prefer to take the approach Sard took and fit with a different distribution (negative binomial). This seems to be the best compromise between getting this done in a timely manner, and limiting the changes to the previous approach. I take this approach below.

Alternatively we could (a) take the time to figure out how to run jmp, (b) use the quasipoisson (approach from before), but eliminate the log-likelihood ratio from table 5 and only report the p values.

Note 2: 
In my original interpretation of the methods section and logs I thought the previous model fits in JMP fit release date as a fixed factor. When I found the actual data provided to JMP I found that Bohn had converted release date to Julian day (continuous numerical predictor). This is a huge relief for interpreting the results, but still isn't optimal, because it doesn't take into account the contribution to variance of batch effects of release dates, only considers a linear relationship between julian day and log(TLF). A mixed model will can do both. 
Also, we are ignoring non-linear relationships. What if julian day is strongly predictive of fitness but not linear - e.g. stabilizing selection with greatest fitness observed in the middle of the distribution but poor fitness at extremes.

Note 3:  
The draft report methods state that interaction terms are fit in the model, but the results table shows model fits without interaction terms. Was there some stage of analysis where the model fits were analyzed with and without interaction terms (i.e. model selection)? Was the data examined for a potential interaction between release date and sex? How was this decision made? It seems like if the likelihood ratio test for interaction term was not significant it was dropped fromthe model. I did not fit the interaction term to follow what was done in the final version of the results, but when we discuss changing this part of the report this isn't something we should skip over.

__Approach Outline__  
For each of the years below, I first present the structure of the data to determine if the full model can be fit. Then I fit the full model and test it using a log-likelihood ratio test against a null model that contains only an intercept. If there is a signifcant global/full model and evidence that predictors have significant effect (Wald test + likelihood ratio test), then I proceed to model validation and model selection and present estimates of effects of predictors of fitness.



### 2011
```{r}
# data
glm_2011_data <- parents %>%
  filter(type == "outplant", year == "2011") %>%
  select(date, geno_sex, location, tlf) %>%
  drop_na() %>%
  mutate(jday = as.numeric(format(date, "%j"))) %>%
  mutate(date = as.factor(date), geno_sex = as.factor(geno_sex), location = as.factor(location))

str(glm_2011_data)
```

For 2011, there is only a single release location and 3 dates. We will not include location in the model.

Let's fit the model and test for global significance. 
```{r}
#glm_2011 <- glm.nb(tlf ~ geno_sex + date +geno_sex*date , data = glm_2011_data)
glm_2011_full <- glm.nb(tlf ~ geno_sex + jday  , data = glm_2011_data)
glm_2011_null <- glm.nb(tlf ~ 1 , data = glm_2011_data)

# test for global
anova(glm_2011_null, glm_2011_full, test = "Chisq")
summary(glm_2011_full)
```

Let's conduct LR tests on each predictor.

```{r}
dropterm(glm_2011_full, test = "Chisq")
```



The global model is insignificant and Wald and LR Tests of each predictor are not significant. Do not proceed with model selection.

### 2012
```{r}
# data
glm_2012_data <- parents %>%
  filter(type == "outplant", year == "2012") %>%
  select(date, geno_sex, location, tlf) %>%
  drop_na() %>%
  mutate(jday = as.numeric(format(date, "%j"))) %>%
  mutate(date = as.factor(date), geno_sex = as.factor(geno_sex), location = as.factor(location))

str(glm_2012_data)
```

For 2012, we will fit the full model

Let's fit the model and test for global significance. 
```{r}
#glm_2011 <- glm.nb(tlf ~ geno_sex + date +geno_sex*date , data = glm_2011_data)
glm_2012_full <- glm.nb(tlf ~ geno_sex + jday + location  , data = glm_2012_data)
glm_2012_null <- glm.nb(tlf ~ 1 , data = glm_2012_data)

# test for global
anova(glm_2012_null, glm_2012_full, test = "Chisq")
summary(glm_2012_full)
```

Let's conduct LR tests on each predictor.

```{r}
dropterm(glm_2012_full, test = "Chisq")
```

The global model is insignificant and Wald Tests of each predictor are not significant. Do not proceed with model selection

### 2013
```{r}
# data
glm_2013_data <- parents %>%
  filter(type == "outplant", year == "2013") %>%
  select(date, geno_sex, location, tlf) %>%
  drop_na() %>%
  mutate(jday = as.numeric(format(date, "%j"))) %>%
  mutate(date = as.factor(date), geno_sex = as.factor(geno_sex), location = as.factor(location))

str(glm_2013_data)
```

For 2013, we will fit the full model

Let's fit the model and test for global significance. 
```{r}
#glm_2011 <- glm.nb(tlf ~ geno_sex + date +geno_sex*date , data = glm_2011_data)
glm_2013_full <- glm.nb(tlf ~ geno_sex + jday + location , data = glm_2013_data)
glm_2013_null <- glm.nb(tlf ~ 1 , data = glm_2013_data)

# test for global
anova(glm_2013_null, glm_2013_full, test = "Chisq")
summary(glm_2013_full)
```

Let's conduct LR tests on each predictor.

```{r}
dropterm(glm_2013_full, test = "Chisq")
```

The global model is insignificant and Wald and LR Tests of each predictor are not significant. Do not proceed with model selection.


### 2014
```{r}
# data
glm_2014_data <- parents %>%
  filter(type == "outplant", year == "2014") %>%
  select(date, geno_sex, location, tlf) %>%
  drop_na() %>%
  mutate(jday = as.numeric(format(date, "%j"))) %>%
  mutate(date = as.factor(date), geno_sex = as.factor(geno_sex), location = as.factor(location))

str(glm_2014_data)
```

For 2014, we will fit the full model

Let's fit the model and test for global significance. 
```{r}
#glm_2011 <- glm.nb(tlf ~ geno_sex + date +geno_sex*date , data = glm_2011_data)
glm_2014_full <- glm.nb(tlf ~ geno_sex + jday + location  , data = glm_2014_data)
glm_2014_null <- glm.nb(tlf ~ 1 , data = glm_2014_data)

# test for global
anova(glm_2014_null, glm_2014_full, test = "Chisq")
summary(glm_2014_full)
```

Let's conduct LR tests on each predictor.

```{r}
dropterm(glm_2014_full, test = "Chisq")
```


The global model is insignificant and but sex has a significant effect (according to Wald Test and LRT). Do not proceed with model selection as this could lead to overfitting (global model not significant). Let's do model validation though.


```{r}
simulationOutput <- simulateResiduals(fittedModel = glm_2014_full, plot = F)
plot(simulationOutput)
```

Model is a poor fit to the data, likely due to outliers. It seems there is dependence between the predicted values and the residuals. The model fit in JMP also failed validation, but the result was not reported. 



Let's convert the paramter estimate to something more easy to interpret (invert the tranformation back to fitness)

```{r}
exp(coef(glm_2014_full))


```

Males have predicted 57% fitness of females in 2014.

My take is that this absolutely should not be included in the draft as a significant effect of sex. We are violating model assumptions. We should explore why model validation failed and evaluate how severe of a problem we are dealing with. Maybe we're comfortable with this level of goodness of fit? Alternatively, maybe the model needs to be specified differently or we need to remove outliers. 

### 2015
```{r}
# data
glm_2015_data <- parents %>%
  filter(type == "outplant", year == "2015") %>%
  select(date, geno_sex, location, tlf) %>%
  drop_na() %>%
  mutate(jday = as.numeric(format(date, "%j"))) %>%
  mutate(date = as.factor(date), geno_sex = as.factor(geno_sex), location = as.factor(location))

str(glm_2015_data)
```

For 2015, we will fit the full model

Let's fit the model and test for global significance. 
```{r}
#glm_2011 <- glm.nb(tlf ~ geno_sex + date +geno_sex*date , data = glm_2011_data)
glm_2015_full <- glm.nb(tlf ~ geno_sex + jday + location  , data = glm_2015_data)
glm_2015_null <- glm.nb(tlf ~ 1 , data = glm_2015_data)

# test for global
anova(glm_2015_null, glm_2015_full, test = "Chisq")
summary(glm_2015_full)
```

Let's conduct LR tests on each predictor.

```{r}
dropterm(glm_2015_full, test = "Chisq")
```

Global model is significant. Sex has signifcant effect by Wald and LRT. Let's do model validation.

```{r}
simulationOutput <- simulateResiduals(fittedModel = glm_2015_full, plot = F)
plot(simulationOutput)
```

This model also has some issues, though less severe. The magnitude of residuals is not independent of the fitted values. For fun, let's see if one variable is causing the problem.

```{r}
plotResiduals(simulationOutput, form = glm_2015_data$geno_sex)
plotResiduals(simulationOutput, form = glm_2015_data$location)
plotResiduals(simulationOutput, form = glm_2015_data$jday)

```

Nope, all looks good. Let's save further diagnosis until after we get the first draft (exactly as done before) completed.

We will do model selection though, since it is quick.

```{r,  results='hide'}
msl_2015 <- stepAIC(glm_2015_full, direction = "backward")
msl_2015$anova
anova(msl_2015)
simulationOutput <- simulateResiduals(fittedModel = msl_2015, plot = F)
plot(simulationOutput)
```

The best final model using stepwise model selection on AIC includes sex and location. It appear getting rid of Julian day solved the model fit issues.Let's take a look at the coefficients from this model.

```{r}
summary(msl_2015)
```

 I'll convert the coefficients into something easier to understand by taking the inverse of the log transformation of the effects (e.g. exp(parameter estimate)).

```{r}
exp(glm_2015_full$coefficients)
```

Males have predicted 72% of females in 2015 


## Mixed Model (code not evaluated in the copy of the notebook)

Here we explore alternative model specifications for predictors of lifetime fitness.

Compared to the approach taken previously I think we can fit a model that provides more power to predict signficant effects on fitness. I think date should be modeled as a continuous fixed variable (e.g. Julian day), we should add a variable - release group – that should be modeled as a random effect, and all years should be combined into the same model (year included as a second random effect).

I made a note of the rationale here below, in case we want to discuss in the future.

Fitting date as a fixed categorical effect effectively asks if each individual release date is different from others. i.e. did something happen ON THAT DAY that changed the fitness of released fish compared to other days. This may be important to know, but what can this tell us that will allow an improvement to management practices? Simply that some days are better than other. This is an interesting result, but I think we can say more. For example, it doesn’t incorporate the autocorrelation in this variable that most readers include intuitively when trying to understand the questions we asking with our model. Tossing out this autocorrelation also reduces our power to find significant effects. For example, shouldn’t our model assume that two release dates closer together have more similar effects on fitness than two dates further apart, and if so, doesn’t this suggest the effect is significant? Put another way,including the effect of release date as a fixed, continuous variable is more appropriate if we are interested in evaluating the putative effect on fitness of environmental variables that vary over time and are therefore autocorrelated.

There are also day-to-day release batch effects, of course, but these are better fit as random effects because we are more interested in their contribution to variance than their fixed effect per se (e.g. we assume release batch effects are part of population of unsampled batch effects that contribute to variance). A good way to think about this is that if we added infinite years of data, there would be infinitely more levels of these effects, suggesting this is best modeled as a random effect, but eventually we'd saturate the julian day of release. Since these two variables (release batch and julian day of release) are so strongly confounded we may have very limited power to evaluate the fixed effect after accounting for the random, unless we combine years.

By fitting just one model across all years, we increase power to estimate the effects of variables because levels the variables take are repeated across multiple years. (e.g. if releases into the resevoir are somehow reducing fitness, why are we trying to figure this out looking one year at a time, when there are releases there every year). Here we are not interested in year over year trends in fitness or the contributions of specific years to fitness as much as we are interested in the variation due to year and evaluating the effects of release date, sex and release location after accounting for annual variation. This suggests we should fit year as a random effect. Fitting year as a fixed effect asks a different question and perhaps we should evaluate this as well.

Finally, I don't think there's any good reason to assume a linear relationship between Julian day and fitness. We should expect stabilizing selection, suggesting that we should evaluate a quadratic effect of Julian day (after scaling and centering) on fitness. 

### Global model

Let's prepare the data. We need two additional variables (release group and julian day).

```{r, eval = FALSE}
mm_data <-  parents %>%
  filter(type == "outplant", year <2016) %>%
  select(date, geno_sex, location, tlf, year) %>%
  drop_na() %>%
  mutate(jday = as.numeric(format(date, "%j"))) %>% #julian day in this case: days since the first day of the year
  mutate(jday_c = scale(jday, scale = T),#center the julian day to help with convergence
         geno_sex = as.factor(geno_sex),
         location = as.factor(location),
         year = as.factor(year),
         group = as.factor(paste(date, location))) 


```

Now lets fit the global model and test for signficance.

```{r, cache = TRUE, eval = FALSE}
mm_full <- glmer.nb(tlf ~ jday_c + geno_sex + location + geno_sex*location + (1|group) + (1|year), data = mm_data) 
mm_null <- glmer.nb(tlf ~ 1+ (1|date)+ (1|year), data = mm_data) 

anova(mm_null, mm_full)
```

Global model is significant. Let's look at the quality of the fit.

```{r, eval = FALSE}

plot(mm_full,type=c("p","smooth"))
plot(mm_full,sqrt((resid(.)))~fitted(.), type=c("p","smooth"),ylab=expression(sqrt((resid))))

plot(mm_full,year~resid(.))
plot(mm_full,group~resid(.))
```

There's some issues with the full model:  

Group random effect doesn't seem to be doing much. The variance driven by group is only about 1/70th of the variance driven by year. We will probably benefit from removing this variance term from the final model.  
The magnitude of the standardized residuals doesn't depend on the fitted values, which is good, but we see that the residuals themselves are quite large, indicating that it is not a very powerful model. 

Let's see if we can specify a better model.  

### Model Selection

We will follow the approach from Zuur et al 2009: First find the optimum random structure by including the fully saturated fixed model, but varying the random effects. Choose by AIC. Then fit all possible fixed effect structures with this "best" random effect structure. Choose best here by AIC as well. 

First the random effects:
```{r, cache = TRUE, eval = FALSE}
mm_linear <- glm.nb(tlf ~ jday_c + geno_sex + location + geno_sex*location, data = mm_data) 
mm_ran_1 <- glmer.nb(tlf ~ jday_c + geno_sex + location + geno_sex*location+ (1|group), data = mm_data) 
mm_ran_2 <- glmer.nb(tlf ~ jday_c + geno_sex + location + geno_sex*location+ (1|year), data = mm_data) 
#mm_full <- glmer.nb(tlf ~ jday_c + geno_sex + location + geno_sex*location+ (1|group) + (1|year), data = mm_data) 

```

```{r, eval = FALSE}
AIC(mm_linear, mm_ran_1, mm_ran_2, mm_full)
```

The full random model and the random model with only year as random effect were within 2 AIC. This suggests they are equivalent and we should choose the one with the fewest parameters. So our final random effect structure is just year.

Now that we the optimum random effect structure, let's find the fixed effect structure:

```{r, eval = FALSE}
# 3 effects
mm_f1 <- glmer.nb(tlf ~ jday_c + geno_sex + location + (1|year), data = mm_data) 
mm_f2 <- glmer.nb(tlf ~ jday_c + geno_sex +  geno_sex*location+ (1|year), data = mm_data) 
mm_f3 <- glmer.nb(tlf ~ jday_c  + location + geno_sex*location+ (1|year), data = mm_data) 
mm_f4 <- glmer.nb(tlf ~ geno_sex + location + geno_sex*location+ (1|year), data = mm_data) 

# 2 effects
mm_f5 <- glmer.nb(tlf ~ jday_c + geno_sex + (1|year), data = mm_data) 
mm_f6 <- glmer.nb(tlf ~ jday_c + location + (1|year), data = mm_data) 
mm_f7 <- glmer.nb(tlf ~ jday_c + geno_sex*location + (1|year), data = mm_data) 
mm_f8 <- glmer.nb(tlf ~ geno_sex + location + (1|year), data = mm_data) 
mm_f9 <- glmer.nb(tlf ~ geno_sex + geno_sex*location + (1|year), data = mm_data) 
mm_f10 <- glmer.nb(tlf ~ location + geno_sex*location + (1|year), data = mm_data) 

# 1 effects
mm_f11 <- glmer.nb(tlf ~ jday_c + (1|year), data = mm_data) 
mm_f12 <- glmer.nb(tlf ~ geno_sex + (1|year), data = mm_data) 
mm_f13 <- glmer.nb(tlf ~ location + (1|year), data = mm_data) 
mm_f14 <- glmer.nb(tlf ~ geno_sex*location + (1|year), data = mm_data) 

AIC(mm_f1, mm_f2, mm_f3, mm_f4, mm_f5, mm_f6, mm_f7, mm_f8, mm_f9, mm_f10, mm_f11, mm_f12, mm_f13, mm_f14)
```


### Final Model

The final model includes 2 fixed (sex and julian day) and one random effect (year). Results from thsi model are below.

First let's get the likelihood ratios, df, and p-values (from chi-square test) for each effect 
```{r, eval = FALSE}
kable(anova(mm_f12, mm_f5), caption = "LRT for Julian Day", align = "c") %>% # jday
  kable_classic(full_width = F, html_font = "Arial")
  
kable(anova(mm_f11, mm_f5), caption = "LRT for Sex", align = "c") %>% # jday
  kable_classic(full_width = F, html_font = "Arial")  
  
```

let's stop until I can get better at mixed modeling. some resources to read

Zuur book 1 
Zuur book 2 (should we consider zero inflation) Zuur, A. F. S., A. A. Ieno. 2012. Zero inflated models and generalized linear mixed models with R.
Bolker faq: bbolker.github.io/mixedmodels-misc
Bolker, B. M., M. E. Brooks, C. J. Clark, S. W. Geange, J. R. Poulsen, M. H. H. Stevens, and J.-S. S. White. 2009. Generalized linear mixed models: a practical guide for ecology and evolution. Trends in Ecology & Evolution 24:127–135.


# Effective Number of Breeders

Calculated Nb using LD method from NeEstimator v2.1. Used GUI, so only logging the parameters used here, not calculating the values.

Parameters:  
MAF: 0.02  
CIs: 95% confidence intervals from jacknife re-sampling method  
Data: Data for a given year is the assigned offspring of that year  

__Issues__  
Note that there are two issues that are a little confusing here and may warrant resolving:  

_Which Cohorts: Outplant and Reintros OR Above and Below?_   
We include all offspring that have at least one assigned offspring to a parent cohort as part of that parent cohort's dataset used to estimate Nb. There are two parent cohorts under consideration in the analysis: reintros, and outplants (3 if you also include rentros above Detroit). However there are only two biological parent cohorts, above Detroit and below Big Cliff. Carcass samples appear in the pedigree as parents with both outplants (above) and reintros (below), so they can be part of either cohort, either because the carcass was sampled above the dam (n = 15) or because the carcass was sampled below the dam (n = 427), and spawned below the dam, or spawned above the dam but passed over/through the dam after spawning.  
As a consequence, our understanding of the census size of successful spawners in a cohort (as estimated by the number of parents in a given year/group with assigned offspring) is biased downwards, because any carcass samples from fish that spawned successfully as a member of this cohort are not counted.
Since we can't say for sure if a carcass was part of the above or below dam cohort unless it's spawning partner is assigned (e.g it is part of a parent-offspring trio with a non-carcass sample parent), we can't simply add all carcass parentages to the total. However, we can count a carcass sample as part of the above or below dam cohort if it is a member of a trio. In the results below I present both numbers, we can choose which to include in the report down the road.

_Single Parents_  
A second way to improve our count of prents in a cohort would be to infer a second parent for single parent matches. If a offspring is assigned to a single parent, we can assume there was a second parent and the assignment was not made because (i) the parent was not included in our set of candidate parents because it was not sampled, (ii) the parent was sampled, but not included in our set of candidate parents because ithad insufficient data to be included, or (iii) the second parent was in the datset but incorrectly excluded due to assignment criteria. 

In the case of (i) or (ii) we could simply add a second parent to the counts and imporve our estimate of the number of parents in a cohort. However the possibility of (iii) presents a problem. We might double count an individual, if it is excluded from some parentages, but not others. Also, we may over estimate the number of parents if an inferred excluded parent contributed to multiple parentages. I do not attempt to infer the number of parents accounting for single parentage because of these multiple issues.

## Outplants

### 2011 

Let's create the input data for NeEstimator. We'll take advantage of a wrapper function from adegenet to output a genepop file all assigned offspring for each parent year.

```{r}
# Here we filter the genotype data to get only offspring from 2011 cohor
offspring_of_2011 <- pedigree_meta %>%
  filter(mother_year == 2011 | father_year ==2011) %>%
  filter(mother_type  == "outplant" | father_type == "outplant") %>%
  pull(offspring_sample_id)

gts_off_of_2011 <- full_meta %>%
  filter(sample_id %in% offspring_of_2011) %>%
  select(sample_id, starts_with(c("Ot", "Ogo", "SSa"))) %>% #grab the genotypes
  mutate(across(.cols = everything(), ~na_if(., "0")))

#now we put bth alleles into a single column for each locus
gts_off_of_2011 %<>%
  gather(key = var, value = value, -sample_id) %>%
  mutate(var = str_extract(var, "\\d+") %>% as.numeric()) %>% 
  group_by(sample_id, var) %>%
  summarise(combined = paste(value, collapse = "")) %>% 
  spread(key = var, value = combined) 

# add a dummy pop variable for conversion, fix NAs
gts_off_of_2011 %<>%
  add_column(pop = "p") %>%
  relocate(sample_id, pop) %>%
  mutate(across(.cols = everything(), ~str_replace(., "NANA", "000000")))

#write_genepop_zlr(loci = gts_off_of_2011[,3:ncol(gts_off_of_2011)],pops = gts_off_of_2011$pop,ind.ids = gts_off_of_2011$sample_id,folder = "neestimator/outplants/",filename ="genepop_2011.txt",ncode = 3,diploid = T)


```

Neestimator results are not formatted to be easily parsed by machine. Instead, wrote results manually to a spreadsheet. We'll import it in the end.

### 2012

```{r}
# Here we filter the genotype data to get only offspring from 2011 cohor
offspring_of_2012 <- pedigree_meta %>%
  filter(mother_year == 2012 | father_year ==2012) %>%
  filter(mother_type  == "outplant" | father_type == "outplant") %>%
  pull(offspring_sample_id)

gts_off_of_2012 <- full_meta %>%
  filter(sample_id %in% offspring_of_2012) %>%
  select(sample_id, starts_with(c("Ot", "Ogo", "SSa"))) %>% #grab the genotypes
  mutate(across(.cols = everything(), ~na_if(., "0")))

#now we put bth alleles into a single column for each locus
gts_off_of_2012 %<>%
  gather(key = var, value = value, -sample_id) %>%
  mutate(var = str_extract(var, "\\d+") %>% as.numeric()) %>% 
  group_by(sample_id, var) %>%
  summarise(combined = paste(value, collapse = "")) %>% 
  spread(key = var, value = combined) 

# add a dummy pop variable for conversion, fix NAs
gts_off_of_2012 %<>%
  add_column(pop = "p") %>%
  relocate(sample_id, pop) %>%
  mutate(across(.cols = everything(), ~str_replace(., "NANA", "000000")))

#write_genepop_zlr(loci = gts_off_of_2012[,3:ncol(gts_off_of_2012)],pops = gts_off_of_2012$pop,ind.ids = gts_off_of_2012$sample_id,folder = "neestimator/outplants/",filename ="genepop_2012.txt",ncode = 3,diploid = T)


```

### 2013

```{r}
# Here we filter the genotype data to get only offspring from 2011 cohor
offspring_of_2013 <- pedigree_meta %>%
  filter(mother_year == 2013 | father_year ==2013) %>%
  filter(mother_type  == "outplant" | father_type == "outplant") %>%
  pull(offspring_sample_id)

gts_off_of_2013 <- full_meta %>%
  filter(sample_id %in% offspring_of_2013) %>%
  select(sample_id, starts_with(c("Ot", "Ogo", "SSa"))) %>% #grab the genotypes
  mutate(across(.cols = everything(), ~na_if(., "0")))

#now we put bth alleles into a single column for each locus
gts_off_of_2013 %<>%
  gather(key = var, value = value, -sample_id) %>%
  mutate(var = str_extract(var, "\\d+") %>% as.numeric()) %>% 
  group_by(sample_id, var) %>%
  summarise(combined = paste(value, collapse = "")) %>% 
  spread(key = var, value = combined) 

# add a dummy pop variable for conversion, fix NAs
gts_off_of_2013 %<>%
  add_column(pop = "p") %>%
  relocate(sample_id, pop) %>%
  mutate(across(.cols = everything(), ~str_replace(., "NANA", "000000")))

#write_genepop_zlr(loci = gts_off_of_2013[,3:ncol(gts_off_of_2013)],pops = gts_off_of_2013$pop,ind.ids = gts_off_of_2013$sample_id,folder = "neestimator/outplants/",filename ="genepop_2013.txt",ncode = 3,diploid = T)


```

```{r}
# Here we filter the genotype data to get only offspring from 2011 cohor
offspring_of_2014 <- pedigree_meta %>%
  filter(mother_year == 2014 | father_year ==2014) %>%
  filter(mother_type  == "outplant" | father_type == "outplant") %>%
  pull(offspring_sample_id)

gts_off_of_2014 <- full_meta %>%
  filter(sample_id %in% offspring_of_2014) %>%
  select(sample_id, starts_with(c("Ot", "Ogo", "SSa"))) %>% #grab the genotypes
  mutate(across(.cols = everything(), ~na_if(., "0")))

#now we put bth alleles into a single column for each locus
gts_off_of_2014 %<>%
  gather(key = var, value = value, -sample_id) %>%
  mutate(var = str_extract(var, "\\d+") %>% as.numeric()) %>% 
  group_by(sample_id, var) %>%
  summarise(combined = paste(value, collapse = "")) %>% 
  spread(key = var, value = combined) 

# add a dummy pop variable for conversion, fix NAs
gts_off_of_2014 %<>%
  add_column(pop = "p") %>%
  relocate(sample_id, pop) %>%
  mutate(across(.cols = everything(), ~str_replace(., "NANA", "000000")))

#write_genepop_zlr(loci = gts_off_of_2014[,3:ncol(gts_off_of_2014)],pops = gts_off_of_2014$pop,ind.ids = gts_off_of_2014$sample_id,folder = "neestimator/outplants/",filename ="genepop_2014.txt",ncode = 3,diploid = T)


```

### 2015

```{r}
# Here we filter the genotype data to get only offspring from 2011 cohor
offspring_of_2015 <- pedigree_meta %>%
  filter(mother_year == 2015 | father_year ==2015) %>%
  filter(mother_type  == "outplant" | father_type == "outplant") %>%
  pull(offspring_sample_id)

gts_off_of_2015 <- full_meta %>%
  filter(sample_id %in% offspring_of_2015) %>%
  select(sample_id, starts_with(c("Ot", "Ogo", "SSa"))) %>% #grab the genotypes
  mutate(across(.cols = everything(), ~na_if(., "0")))

#now we put bth alleles into a single column for each locus
gts_off_of_2015 %<>%
  gather(key = var, value = value, -sample_id) %>%
  mutate(var = str_extract(var, "\\d+") %>% as.numeric()) %>% 
  group_by(sample_id, var) %>%
  summarise(combined = paste(value, collapse = "")) %>% 
  spread(key = var, value = combined) 

# add a dummy pop variable for conversion, fix NAs
gts_off_of_2015 %<>%
  add_column(pop = "p") %>%
  relocate(sample_id, pop) %>%
  mutate(across(.cols = everything(), ~str_replace(., "NANA", "000000")))

#write_genepop_zlr(loci = gts_off_of_2015[,3:ncol(gts_off_of_2015)],pops = gts_off_of_2015$pop,ind.ids = gts_off_of_2015$sample_id,folder = "neestimator/outplants/",filename ="genepop_2015.txt",ncode = 3,diploid = T)


```

## Reintros

### Reintro Above (2015)

```{r}
# Here we filter the genotype data to get only offspring from 2011 cohor
offspring_of_2015 <- pedigree_meta %>%
  filter(mother_year == 2015 | father_year ==2015) %>%
  filter(mother_type  == "reintro_above" | father_type == "reintro_above") %>%
  pull(offspring_sample_id)

gts_off_of_2015 <- full_meta %>%
  filter(sample_id %in% offspring_of_2015) %>%
  select(sample_id, starts_with(c("Ot", "Ogo", "SSa"))) %>% #grab the genotypes
  mutate(across(.cols = everything(), ~na_if(., "0")))

#now we put bth alleles into a single column for each locus
gts_off_of_2015 %<>%
  gather(key = var, value = value, -sample_id) %>%
  mutate(var = str_extract(var, "\\d+") %>% as.numeric()) %>% 
  group_by(sample_id, var) %>%
  summarise(combined = paste(value, collapse = "")) %>% 
  spread(key = var, value = combined) 

# add a dummy pop variable for conversion, fix NAs
gts_off_of_2015 %<>%
  add_column(pop = "p") %>%
  relocate(sample_id, pop) %>%
  mutate(across(.cols = everything(), ~str_replace(., "NANA", "000000")))

#write_genepop_zlr(loci = gts_off_of_2015[,3:ncol(gts_off_of_2015)],pops = gts_off_of_2015$pop,ind.ids = gts_off_of_2015$sample_id,folder = "neestimator/reintros/",filename ="genepop_2015_above.txt",ncode = 3,diploid = T)


```

### Reintro Below (2013)

```{r}
# Here we filter the genotype data to get only offspring from 2011 cohor
offspring_of_2013 <- pedigree_meta %>%
  filter(mother_year == 2013 | father_year ==2013) %>%
  filter(mother_type  == "reintro" | father_type == "reintro") %>%
  pull(offspring_sample_id)

gts_off_of_2013 <- full_meta %>%
  filter(sample_id %in% offspring_of_2013) %>%
  select(sample_id, starts_with(c("Ot", "Ogo", "SSa"))) %>% #grab the genotypes
  mutate(across(.cols = everything(), ~na_if(., "0")))

#now we put bth alleles into a single column for each locus
gts_off_of_2013 %<>%
  gather(key = var, value = value, -sample_id) %>%
  mutate(var = str_extract(var, "\\d+") %>% as.numeric()) %>% 
  group_by(sample_id, var) %>%
  summarise(combined = paste(value, collapse = "")) %>% 
  spread(key = var, value = combined) 

# add a dummy pop variable for conversion, fix NAs
gts_off_of_2013 %<>%
  add_column(pop = "p") %>%
  relocate(sample_id, pop) %>%
  mutate(across(.cols = everything(), ~str_replace(., "NANA", "000000")))

#write_genepop_zlr(loci = gts_off_of_2013[,3:ncol(gts_off_of_2013)],pops = gts_off_of_2013$pop,ind.ids = gts_off_of_2013$sample_id,folder = "neestimator/reintros/",filename ="genepop_2013.txt",ncode = 3,diploid = T)


```


### Reintro Below (2014)

```{r}
# Here we filter the genotype data to get only offspring from 2011 cohor
offspring_of_2014 <- pedigree_meta %>%
  filter(mother_year == 2014 | father_year ==2014) %>%
  filter(mother_type  == "reintro" | father_type == "reintro") %>%
  pull(offspring_sample_id)

gts_off_of_2014 <- full_meta %>%
  filter(sample_id %in% offspring_of_2014) %>%
  select(sample_id, starts_with(c("Ot", "Ogo", "SSa"))) %>% #grab the genotypes
  mutate(across(.cols = everything(), ~na_if(., "0")))

#now we put bth alleles into a single column for each locus
gts_off_of_2014 %<>%
  gather(key = var, value = value, -sample_id) %>%
  mutate(var = str_extract(var, "\\d+") %>% as.numeric()) %>% 
  group_by(sample_id, var) %>%
  summarise(combined = paste(value, collapse = "")) %>% 
  spread(key = var, value = combined) 

# add a dummy pop variable for conversion, fix NAs
gts_off_of_2014 %<>%
  add_column(pop = "p") %>%
  relocate(sample_id, pop) %>%
  mutate(across(.cols = everything(), ~str_replace(., "NANA", "000000")))

#write_genepop_zlr(loci = gts_off_of_2014[,3:ncol(gts_off_of_2014)],pops = gts_off_of_2014$pop,ind.ids = gts_off_of_2014$sample_id,folder = "neestimator/reintros/",filename ="genepop_2014.txt",ncode = 3,diploid = T)


```

### Reintro Below (2015)

```{r}
# Here we filter the genotype data to get only offspring from 2011 cohor
offspring_of_2015 <- pedigree_meta %>%
  filter(mother_year == 2015 | father_year ==2015) %>%
  filter(mother_type  == "reintro" | father_type == "reintro") %>%
  pull(offspring_sample_id)

gts_off_of_2015 <- full_meta %>%
  filter(sample_id %in% offspring_of_2015) %>%
  select(sample_id, starts_with(c("Ot", "Ogo", "SSa"))) %>% #grab the genotypes
  mutate(across(.cols = everything(), ~na_if(., "0")))

#now we put bth alleles into a single column for each locus
gts_off_of_2015 %<>%
  gather(key = var, value = value, -sample_id) %>%
  mutate(var = str_extract(var, "\\d+") %>% as.numeric()) %>% 
  group_by(sample_id, var) %>%
  summarise(combined = paste(value, collapse = "")) %>% 
  spread(key = var, value = combined) 

# add a dummy pop variable for conversion, fix NAs
gts_off_of_2015 %<>%
  add_column(pop = "p") %>%
  relocate(sample_id, pop) %>%
  mutate(across(.cols = everything(), ~str_replace(., "NANA", "000000")))

#write_genepop_zlr(loci = gts_off_of_2015[,3:ncol(gts_off_of_2015)],pops = gts_off_of_2015$pop,ind.ids = gts_off_of_2015$sample_id,folder = "neestimator/reintros/",filename ="genepop_2015.txt",ncode = 3,diploid = T)


```

## Results

```{r, message=FALSE}
nb <- readxl::read_xlsx("neestimator/Nb_results.xlsx", sheet = 1)


#let's add the counts of number of candidate parents, number of successful parents estimated from the pedigree

#get counts total candidates

nb <- meta_data %>%
  mutate(year = as.numeric(year)) %>%
  count(year, type) %>%
  right_join(nb) %>%
  rename(n_candidate_parents = n)

# get basic counts of successful parents (candidate parents in row with at least one offspring)

kable(pedigree_meta %>%
  mutate(parent_year = coalesce(mother_year, father_year)) %>%
  select( parent_year, father_id = father, mother_id = mother, father_type, mother_type) %>%
  pivot_longer(cols = c(father_id, father_type, mother_id, mother_type), names_to = c("parent_sex", ".value"), names_sep = "_") %>%
  filter(id != "none") %>%
  distinct(id, .keep_all = TRUE) %>%
  count(parent_year, type), align = "c", caption = "number of parents with at least one assigned offspring, parents considered individually") %>%
  kable_classic(full_width = F, html_font = "Arial")

#also add these results to the results table
nb <- pedigree_meta %>%
  mutate(parent_year = coalesce(mother_year, father_year)) %>%
  select( parent_year, father_id = father, mother_id = mother, father_type, mother_type) %>%
  pivot_longer(cols = c(father_id, father_type, mother_id, mother_type), names_to = c("parent_sex", ".value"), names_sep = "_") %>%
  filter(id != "none") %>%
  distinct(id, .keep_all = TRUE) %>%
  count(parent_year, type) %>%
  rename(year = parent_year) %>%
  mutate(year = as.numeric(year)) %>%
  right_join(nb) %>%
  rename(n_successful_parents = n)

  
# get counts of different types of parent pairs
kable(pedigree_meta %>%
  mutate(parent_year = coalesce(mother_year, father_year)) %>%
  select(parent_type, parent_year, father, mother) %>%
  pivot_longer(cols = c(father, mother), names_to = "parent_sex", values_to = "parent_id" ) %>%
  filter(parent_id != "none") %>%
  distinct(parent_id, .keep_all = TRUE) %>% 
  count(parent_year, parent_type), align = "c", caption = "number of parents with at least one assigned offspring, types for both parents presented if trio, see note about error in this table") %>%
  kable_classic(full_width = F, html_font = "Arial")

# note there's a problem with this table, we filter duplicates, so when a single individual has spawning partners of multiple types, the count by type is only counted once. For example, a 2015 outplant individual that spawns with both other outplants and reintros is either included in the outplants total or the outplant/reintro total depdending on which is the first (by row order) in the pedigree dataframe. Figuring out the right way to add these up will take some time, so skipping for now unless we really want to include these numbers in the report.

# now present nb

nb %<>%
  mutate(nb_n_ratio = Nb/n_successful_parents) %>%
  relocate(year, type, Nb, ci_lower, ci_higher)

kable(nb, align = "c", caption = "Nb results table") %>% kable_classic(full_width = F, html_font = "Arial") %>%
  footnote(number = c("n_succesful_parents: number of parents with at least one offspring in the final pedigree", "n_candidate_parents: total number of parents included as candidates in the pedigree analysis", "nb_n_ratio: (estimated Nb)/(n_successful_parents)"))
```


Let's ignore the single parent issue for now.  

In the first two tables above we observe that deciding which number to present as the number of parents from the pedigree is not straightforward. In the first table we consider each parent individually, in the second table we consider parent types for both parents in a trio, which is the more informative value to present, because it tells us about the actual cohort of individuals that spawned together. For example, for the 2011 outplant parent cohort, should the number be 51 to reflect only outplants, or 52 to reflect that we know that one carcass individual produced offspring in the pedigree with one outplants? 

We should also discuss why in some groups (all reintro below), the estimated Nb is greater than the number of successful parents in the pedigree. 

__Negative assortative mating?__  
Maybe, but doubtful.   

__Our assignment criteria are too stringent given the amount of mis-genotypting and undersampling of candidate parents?__  
This might be the case, but we can't do much about this right now. It is a bit troubling that the problem is mostly restricted to one type (reintros below)

__The cohort is artificially small because we split by type rather than spawning location?__   
__YES__, we can positively assess this. In 2015, there are 125 parents above the dam that spawned with a different type (reintro vs outplant) than themselves. To accurately reflect the number of parents in the above dam cohort with at least a single offspring in the pedigree we need to use the second table from above. Including all parents we know to contribute above the dam (including carcasses) the inferred number of succesful parents should be 478 (reintros above + outplants + carcasses known to have spawned above the dam). I do some extra work to explore this in the section "2015 Combined" below. 

__Note__ there's a problem with the second table. We filter duplicate parents from the pedigree to get the counts (i.e. count each successful parent once, not once per each offspring it produces), so when a single individual parent has spawning partners of multiple types, the count by type is only counted once. For example, a 2015 outplant individual that spawns with both other outplants and reintros is either included in the outplants total or the outplant/reintro total depdending on which is the first (by row order) in the pedigree dataframe. Figuring out the right way to add these up will take some time, in the interest of time I'm not going to fix this problem, unless we really want to include these numbers in the report. For now, we should just be aware that the counts in the second table are MINIMUMS, not the actual number, but they highlight the question about what is the best way to think about cohort size: by parent type, or by above/below the dams


### 2015 Combined

To further explore the issues described above. I also ran NeEstimator for all parents above Detroit in 2015 (excluding carcasses sampled below the dam, but assigned to have spawned with a second parent above the dam). 


```{r}
# Here we filter the genotype data to get only offspring from 2011 cohor
offspring_of_2015 <- pedigree_meta %>%
  filter(mother_year == 2015 | father_year ==2015) %>%
  filter(mother_type  == "reintro_above" | father_type == "reintro_above" | mother_type == "outplant" | father_type == "outplant" | mother_type == "carcass_above" | father_type == "carcass_above") %>%
  pull(offspring_sample_id)

gts_off_of_2015 <- full_meta %>%
  filter(sample_id %in% offspring_of_2015) %>%
  select(sample_id, starts_with(c("Ot", "Ogo", "SSa"))) %>% #grab the genotypes
  mutate(across(.cols = everything(), ~na_if(., "0")))

#now we put bth alleles into a single column for each locus
gts_off_of_2015 %<>%
  gather(key = var, value = value, -sample_id) %>%
  mutate(var = str_extract(var, "\\d+") %>% as.numeric()) %>% 
  group_by(sample_id, var) %>%
  summarise(combined = paste(value, collapse = "")) %>% 
  spread(key = var, value = combined) 

# add a dummy pop variable for conversion, fix NAs
gts_off_of_2015 %<>%
  add_column(pop = "p") %>%
  relocate(sample_id, pop) %>%
  mutate(across(.cols = everything(), ~str_replace(., "NANA", "000000")))

#write_genepop_zlr(loci = gts_off_of_2015[,3:ncol(gts_off_of_2015)],pops = gts_off_of_2015$pop,ind.ids = gts_off_of_2015$sample_id,folder = "neestimator/2015_above/",filename ="genepop_2015.txt",ncode = 3,diploid = T)


```

For the 2015 above Detroit parent cohort (ignoring carcasses to be consistent with the table as presented earlier), the number of offspring in the dataset was 717, Nb was 332.1 (291.6 - 380.6). Here we see that when considered all of the successful parents above Detroit together, the Nb results are not so problematic. The ratio of Nb to number of successful parents is a more reasonable ~69% (compared to 95% for outplants and 92% for reintros). 






